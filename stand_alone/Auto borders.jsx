/** * Применить уровни * @param {{ *  black: Number, *  white: Number *  gamma: Number * }} data */function levelsAction(data) {    var docRef = activeDocument;    // =======================================================    // Levels    var idLvls = charIDToTypeID( "Lvls" );    var desc188 = new ActionDescriptor();    var idpresetKind = stringIDToTypeID( "presetKind" );    var idpresetKindType = stringIDToTypeID( "presetKindType" );    var idpresetKindCustom = stringIDToTypeID( "presetKindCustom" );    desc188.putEnumerated( idpresetKind, idpresetKindType, idpresetKindCustom );    var idAdjs = charIDToTypeID( "Adjs" );    var list5 = new ActionList();    var desc189 = new ActionDescriptor();    var idChnl = charIDToTypeID( "Chnl" );    var ref88 = new ActionReference();    var idCmps = charIDToTypeID( "Cmps" );    ref88.putEnumerated( idChnl, idChnl, idCmps );    desc189.putReference( idChnl, ref88 );    var idInpt = charIDToTypeID( "Inpt" );    var list6 = new ActionList();    list6.putInteger( data.black || 0);    list6.putInteger( data.white || 255);    desc189.putList( idInpt, list6 );    var idGmm = charIDToTypeID( "Gmm " );    desc189.putDouble( idGmm, data.gamma || 0 );    var idLvlA = charIDToTypeID( "LvlA" );    list5.putObject( idLvlA, desc189 );    desc188.putList( idAdjs, list5 );    executeAction( idLvls, desc188, DialogModes.NO );}/** * Обрезает края изображения по объекту */function trimAction() {    var idtrim = stringIDToTypeID( "trim" );    var desc186 = new ActionDescriptor();    var idtrimBasedOn = stringIDToTypeID( "trimBasedOn" );    var idtopLeftPixelColor = stringIDToTypeID( "topLeftPixelColor" );    desc186.putEnumerated( idtrimBasedOn, idtrimBasedOn, idtopLeftPixelColor );    var idTop = charIDToTypeID( "Top " );    desc186.putBoolean( idTop, true );    var idBtom = charIDToTypeID( "Btom" );    desc186.putBoolean( idBtom, true );    var idLeft = charIDToTypeID( "Left" );    desc186.putBoolean( idLeft, true );    var idRght = charIDToTypeID( "Rght" );    desc186.putBoolean( idRght, true );    executeAction( idtrim, desc186, DialogModes.NO );}function getRulerTypeAbbreviation () {    switch (preferences.rulerUnits) {        case Units.CM:            return 'cm';        case Units.INCHES:            return 'in';        case Units.MM:            return 'mm';        case Units.PERCENT:            return '%';        case Units.PICAS:            return 'pc';        case Units.PIXELS:            return 'px';        case Units.POINTS:            return 'pt';        default:            throw 'Тип не поддерживается [' + preferences.rulerUnits + ']';    }}/** * Возвращает координаты (UnitValue) самых крайних направляющих. * Если направляющая не указана, то берутся границы кадра. * Горизонтальная направляющая может быть одна, в этом случае, она считается нижней. * @returns {{left: *, right: *, top: *, bottom: *, width: *, heigth: *}} */function calculateFrame(doc, units) {    var oldUnits;    if (units) {        oldUnits = preferences.rulerUnits;        preferences.rulerUnits = units;    }    var guides = doc.guides,        zeroUnit = UnitValue('0 ' + getRulerTypeAbbreviation()),        vrtGuides = [],        hrzGuides = [];    // Разделяем направляющие по типу    for (var i = 0, len = guides.length; i < len; i++) {        var guid = guides[i];        guid.direction == 'Direction.VERTICAL' ? //TODO Поменять на ? - "guid.direction === Direction.VERTICAL"            vrtGuides.push(guid) :            hrzGuides.push(guid);    }    var guidesComparer = function (a, b) {        return a.coordinate.as('px') - b.coordinate.as('px');    };    vrtGuides.sort(guidesComparer);    hrzGuides.sort(guidesComparer);    // Рамка по умолчанию соответствует границам документа    var frame = {        left:   zeroUnit,        right:  doc.width,        top:    zeroUnit,        bottom: doc.height,        width: doc.width,        height: doc.height    };    // Обязательное наличие двух вертикальных направляющих для задания по ним рамки    if (vrtGuides.length > 1) {        frame.left =  vrtGuides[0].coordinate;        frame.right = vrtGuides[vrtGuides.length - 1].coordinate;    }    // Горизонтальная направляющая может быть одна (нижняя)    if (hrzGuides.length > 0) {        frame.bottom =  hrzGuides[hrzGuides.length - 1].coordinate;        if (hrzGuides.length > 1) {            frame.top = hrzGuides[0].coordinate;        }    }    if (units) {        preferences.rulerUnits = oldUnits;    }    return frame;}function autoBorders(docRef) {    var curUnits = docRef.width.type;    // Сохраняем текущее состояние, чтобы вернуться после изменений    var savedState = docRef.activeHistoryState;    // Устанавливаем направляющие по границам документа    var guidesList = [        activeDocument.guides.add(Direction.VERTICAL,   UnitValue(0, curUnits)),        activeDocument.guides.add(Direction.HORIZONTAL, UnitValue(0, curUnits)),        activeDocument.guides.add(Direction.VERTICAL,   docRef.width),        activeDocument.guides.add(Direction.HORIZONTAL, docRef.height)    ];    // Применяем уровни чтобы максимально отбросить фон и выделить объект    levelsAction({        black: 70,        white: 180,        gamma: 1    });    // Обрезаем белый фон    trimAction();    // Сохраняем значение направляющих после обрезки границ    var trimmedFrame = calculateFrame(docRef);    // Восстанавливаем состояние    docRef.activeHistoryState = savedState;    /*guidesList[0].direction = -guidesDirections[0];    guidesList[1].direction = -guidesDirections[1];    guidesList[2].direction = docRef.width - guidesDirections[2];    guidesList[3].direction = docRef.height - guidesDirections[3];*/    activeDocument.guides.add(Direction.VERTICAL,   -trimmedFrame.left);    activeDocument.guides.add(Direction.HORIZONTAL, -trimmedFrame.top);    activeDocument.guides.add(Direction.VERTICAL,   docRef.width  - trimmedFrame.right  + trimmedFrame.width);    activeDocument.guides.add(Direction.HORIZONTAL, docRef.height - trimmedFrame.bottom + trimmedFrame.height);}preferences.rulerUnits = Units.PIXELS;activeDocument.guides.removeAll();autoBorders(activeDocument);